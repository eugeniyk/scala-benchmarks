package scala.benchmarks.collections

import java.util
import java.util.concurrent.TimeUnit
import java.util.function.BiConsumer

import org.openjdk.jmh.annotations._
import org.openjdk.jmh.infra.Blackhole

import scala.benchmarks.collections.JMapTest.JMapState

object JMapTest {
  case class Data(string: String, int: Int)

  @State(Scope.Benchmark)
  class JMapState() {
    @Param(Array("1", "10", "100"))
    var collectionSize: Int = 0

    var jmap: java.util.Map[String, String] = _

    @Setup()
    def setup(): Unit = {
      jmap = new util.HashMap[String, String](2*collectionSize)
      (0 to collectionSize).foreach { i =>
        val value = "item" + i
        jmap.put(value, value)
      }
    }

    def foreachMap[A, B](foreach: (A, B) => Unit): BiConsumer[A, B] = {
      new BiConsumer[A, B] {
        override def accept(key: A, value: B): Unit = foreach(key, value)
      }
    }
  }
}

/**
  * This benchmarks is to find out the garbage generated by foldLeft with primitive types
  *
  * sbt "jmh:run -i 10 -wi 5 -f1 -t1 JMapTest.*"
  * sbt "jmh:run -i 10 -wi 5 -f1 -t1 JMapTest.* -prof gc"
  */
@BenchmarkMode(Array(Mode.AverageTime))
@OutputTimeUnit(TimeUnit.NANOSECONDS)
class JMapTest {
  @Benchmark
  def baseline(state: JMapState, bh: Blackhole): Unit = {
    (0 to state.collectionSize).foreach { i =>
      bh.consume(i)
      bh.consume(i)
    }
  }

  @Benchmark
  def foreachJava(state: JMapState, bh: Blackhole): Unit = {
    state.jmap.forEach(new BiConsumer[String, String] {
      override def accept(t: String, u: String): Unit = {
        bh.consume(t)
        bh.consume(u)
      }
    })
  }

  @Benchmark
  def foreachJavaWithSugar(state: JMapState, bh: Blackhole): Unit = {
    state.jmap.forEach(state.foreachMap { (a, b) =>
      bh.consume(a)
      bh.consume(b)
    })
  }

  @Benchmark
  def foreachScala(state: JMapState, bh: Blackhole): Unit = {
    import scala.collection.JavaConverters._
    state.jmap.asScala.foreach { kv =>
      bh.consume(kv._1)
      bh.consume(kv._2)
    }
  }
}


