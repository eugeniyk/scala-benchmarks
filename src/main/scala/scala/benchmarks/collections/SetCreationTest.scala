package scala.benchmarks.collections

import java.util.concurrent.TimeUnit

import org.openjdk.jmh.annotations._

import scala.benchmarks.collections.MapCreationTest.TestState
import scala.collection.JavaConverters._

object SetCreationTest {
  @State(Scope.Benchmark)
  class TestState() {
    @Param(Array("10", "100", "1000"))
    var size: Int = _

    var seq: Seq[Int] = _

    @Setup()
    def setup(): Unit = {
      seq = 1.to(size)
    }
  }
}

/**
  * This benchmarks is to find out the garbage generated by foldLeft with primitive types
  *
  * sbt "jmh:run -i 7 -wi 3 -f1 -t1 ImmutableSetCreationTest.*"
  */
@BenchmarkMode(Array(Mode.AverageTime))
@OutputTimeUnit(TimeUnit.NANOSECONDS)
class ImmutableSetCreationTest {
  @Benchmark
  def standardWay(state: TestState) = {
    val value = state.seq.toSet
    value
  }

  @Benchmark
  def foldFunctionalWay(state: TestState) = {
    val value: Set[Int] = state.seq.foldLeft(Set.empty[Int])((acc, s) => acc + s)
    value
  }

  @Benchmark
  def usingMutableBuilders(state: TestState) = {
    val mutable = scala.collection.mutable.Set[Int]()
    state.seq.foreach(id => mutable += id)
    mutable.to[Set]
  }

  @Benchmark
  def usingJavaReturnScala(state: TestState) = {
    val mutable = new java.util.HashSet[Int](state.size)
    state.seq.foreach(id => mutable.add(id))
    mutable.asScala.to[Set]
  }
}

/**
  * This benchmarks is to find out the garbage generated by foldLeft with primitive types
  *
  * sbt "jmh:run -i 7 -wi 3 -f1 -t1 MutableSetCreationTest.*"
  */
@BenchmarkMode(Array(Mode.AverageTime))
@OutputTimeUnit(TimeUnit.NANOSECONDS)
class MutableSetCreationTest {
  @Benchmark
  def byIterationImplicitBuilds(state: TestState) = {
    val mutable: scala.collection.mutable.Set[Int] = state.seq.map(identity)(collection.breakOut)
    mutable
  }

  @Benchmark
  def explicitBuilders(state: TestState) = {
    val mutable = scala.collection.mutable.Set[Int]()
    state.seq.foreach(id => mutable += id)
    mutable
  }

  @Benchmark
  def usingJavaReturnJava(state: TestState) = {
    val mutable = new java.util.HashSet[Int](state.size)
    state.seq.foreach(id => mutable.add(id))
    mutable
  }

  @Benchmark
  def usingJavaNoSizeHintReturnJava(state: TestState) = {
    val mutable = new java.util.HashSet[Int]()
    state.seq.foreach(id => mutable.add(id))
    mutable
  }

  @Benchmark
  def usingJaveReturnMutableDecorator(state: TestState) = {
    val mutable = new java.util.HashSet[Int](state.size)
    state.seq.foreach(id => mutable.add(id))
    mutable.asScala
  }
}