package scala.benchmarks.collections

import java.util.concurrent.TimeUnit

import org.openjdk.jmh.annotations._

import scala.benchmarks.collections.MapCreationTest.TestState
import scala.collection.JavaConverters._

object MapCreationTest {
  @State(Scope.Benchmark)class TestState() {
    @Param(Array("10", "100", "1000"))
    var size: Int = _

    var seq: Seq[Int] = _

    @Setup()
    def setup(): Unit = {
      seq = 1.to(size)
    }
  }
}

/**
  * This benchmarks is to find out the garbage generated by foldLeft with primitive types
  *
  * sbt "jmh:run -i 7 -wi 3 -f1 -t1 ImmutableMapCreationTest.*"
  */
@BenchmarkMode(Array(Mode.AverageTime))
@OutputTimeUnit(TimeUnit.NANOSECONDS)
class ImmutableMapCreationTest {
//  @Benchmark // ~1ns per element
//  def baseline(state: TestState) = {
//    var counter = 0
//    state.seq.foreach(id => counter += id)
//    counter
//  }

  @Benchmark
  def standardWay(state: TestState) = {
    val value = state.seq.map(id => id -> id).toMap
    value
  }

  @Benchmark
  def avoidIntermediateCollection(state: TestState) = {
    val value: Map[Int, Int] = state.seq.map(id => id -> id)(collection.breakOut)
    value
  }

  @Benchmark
  def foldFunctionalWay(state: TestState) = {
    val value: Map[Int, Int] = state.seq.foldLeft(Map.empty[Int, Int])((acc, s) => acc + (s -> s))
    value
  }

  @Benchmark
  def usingMutableBuilders(state: TestState) = {
    val mutable = scala.collection.mutable.Map[Int, Int]()
    state.seq.foreach(id => mutable += (id -> id))
    mutable.toMap
  }

  @Benchmark
  def usingJavaReturnScala(state: TestState) = {
    val mutable = new java.util.HashMap[Int, Int](state.size)
    state.seq.foreach(id => mutable.put(id, id))
    mutable.asScala.toMap
  }
}

/**
  * This benchmarks is to find out the garbage generated by foldLeft with primitive types
  *
  * sbt "jmh:run -i 7 -wi 3 -f1 -t1 MutableMapCreationTest.*"
  */
@BenchmarkMode(Array(Mode.AverageTime))
@OutputTimeUnit(TimeUnit.NANOSECONDS)
class MutableMapCreationTest {
  @Benchmark
  def byIterationImplicitBuilds(state: TestState) = {
    val mutable: scala.collection.mutable.Map[Int, Int] = state.seq.map(id => id -> id)(collection.breakOut)
    mutable
  }

  @Benchmark
  def explicitBuilders(state: TestState) = {
    val mutable = scala.collection.mutable.Map[Int, Int]()
    state.seq.foreach(id => mutable += (id -> id))
    mutable
  }

  @Benchmark
  def usingJavaReturnJava(state: TestState) = {
    val mutable = new java.util.HashMap[Int, Int](state.size)
    state.seq.foreach(id => mutable.put(id, id))
    mutable
  }

  @Benchmark
  def usingJavaNoSizeHintReturnJava(state: TestState) = {
    val mutable = new java.util.HashMap[Int, Int]()
    state.seq.foreach(id => mutable.put(id, id))
    mutable
  }

  @Benchmark
  def usingJaveReturnMutableDecorator(state: TestState) = {
    val mutable = new java.util.HashMap[Int, Int](state.size)
    state.seq.foreach(id => mutable.put(id, id))
    mutable.asScala
  }
}